diff --git a/src/sheets.ts b/src/sheets.ts
index 0000000..0000000 100644
--- a/src/sheets.ts
+++ b/src/sheets.ts
@@
 export async function updateWithdrawalStatusById(requestId: string, newStatus: string, approvedByUserId?: string): Promise<void> {
   try {
     const svc = await getSheetsClient();

     // Find the row with the request_id
     const res = await retryApiCall(() => svc.spreadsheets.values.get({
       spreadsheetId: SHEET_ID,
       range: 'Withdrawals!A:L'
     }));

     const rows = res.data.values || [];
     let rowIndex = -1;

     for (let i = 0; i < rows.length; i++) {
       if (rows[i][0] === requestId) {
         rowIndex = i + 1; // Sheets is 1-indexed
         break;
       }
     }

     if (rowIndex === -1) {
       throw new Error(`Withdrawal with request_id ${requestId} not found`);
     }

-    // Update status and approval info
-    const updates = [
-      { range: `Withdrawals!I${rowIndex}`, values: [[newStatus]] },
-      { range: `Withdrawals!G${rowIndex}`, values: [[approvedByUserId || '']] },
-      { range: `Withdrawals!H${rowIndex}`, values: [[new Date().toISOString()]] }
-    ];
+    // Columns on Withdrawals:
+    // A request_id
+    // B user_id
+    // C username
+    // D amount_usd
+    // E method
+    // F payment_tag_or_address
+    // G request_timestamp_iso
+    // H approved_by_user_id
+    // I approved_at_iso
+    // J status
+    // K payout_type
+    // L notes
+    // Update status and approval info (correct columns)
+    const updates = [
+      { range: `Withdrawals!H${rowIndex}`, values: [[approvedByUserId || '']] },   // approved_by_user_id
+      { range: `Withdrawals!I${rowIndex}`, values: [[new Date().toISOString()]] }, // approved_at_iso
+      { range: `Withdrawals!J${rowIndex}`, values: [[newStatus]] }                  // status
+    ];

     await retryApiCall(() => svc.spreadsheets.values.batchUpdate({
       spreadsheetId: SHEET_ID,
       requestBody: {
         valueInputOption: 'USER_ENTERED',
         data: updates
       }
     }));

     // Invalidate cache
     invalidateCashoutsCache();

     console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] Updated withdrawal ${requestId} to status: ${newStatus}`);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Failed to update withdrawal status:`, error);
     throw error;
   }
 }
@@
 async function ensureSheetHeaders(sheetName: string): Promise<void> {
@@
     switch (sheetName) {
       case 'Withdrawals':
         headers = [
           'request_id', 'user_id', 'username', 'amount_usd', 'method', 
           'payment_tag_or_address', 'request_timestamp_iso', 'approved_by_user_id', 
           'approved_at_iso', 'status', 'payout_type', 'notes'
         ];
         break;
       case 'OwnerPayouts':
-        headers = [
-          'request_id', 'user_id', 'username', 'amount_usd', 'method', 
-          'payment_tag_or_address', 'request_timestamp_iso', 'status', 'notes'
-        ];
+        // Align headers with appendOwnerPayout (10 columns)
+        headers = [
+          'payout_id',               // A
+          'user_id',                 // B
+          'username',                // C
+          'amount_usd',              // D
+          'channel',                 // E  (e.g., PAYPAL/BTC/ETH)
+          'owner_wallet_or_handle',  // F  (clubâ€™s payout wallet/handle if any)
+          'request_timestamp_iso',   // G
+          'paid_at_iso',             // H
+          'status',                  // I
+          'notes'                    // J
+        ];
         break;
       case 'ExternalDeposits':
         headers = [
           'entry_id', 'user_id', 'username', 'amount_usd', 'method', 
           'reference', 'created_at_iso', 'recorded_by_user_id'
         ];
@@
 export async function appendOwnerPayout(row: {
   payout_id: string;
   user_id: string|number;
   username: string;
   amount_usd: number;
   channel: string; // PAYPAL | BTC | ETH | ...
   owner_wallet_or_handle: string;
   request_timestamp_iso: string;
   status: 'PENDING'|'PAID'|'CANCELLED';
   notes?: string;
 }): Promise<void> {
@@
-    await retryApiCall(() => svc.spreadsheets.values.append({
+    await retryApiCall(() => svc.spreadsheets.values.append({
       spreadsheetId: SHEET_ID,
       range: 'OwnerPayouts!A:J',
       valueInputOption: 'USER_ENTERED',
       requestBody: { values: [payoutRow] }
     }));
@@
 export async function markOwnerPayoutPaid(payoutId: string, markedByUserId: number, note: string): Promise<void> {
   try {
     const svc = await getSheetsClient();

     // Find the payout in OwnerPayouts sheet
     const res = await retryApiCall(() => svc.spreadsheets.values.get({
       spreadsheetId: SHEET_ID,
       range: 'OwnerPayouts!A:J'
     }));

     const rows = res.data.values || [];
     let rowIndex = -1;

     for (let i = 1; i < rows.length; i++) {
       if (rows[i][0] === payoutId) {
         rowIndex = i + 1; // Convert to 1-based index
         break;
       }
     }

     if (rowIndex === -1) {
       throw new Error(`Owner payout ${payoutId} not found`);
     }

-    // Update status to PAID
-    await retryApiCall(() => svc.spreadsheets.values.update({
-      spreadsheetId: SHEET_ID,
-      range: `OwnerPayouts!H${rowIndex}`,
-      valueInputOption: 'USER_ENTERED',
-      requestBody: { values: [['PAID']] }
-    }));
-    
-    // Update notes
-    await retryApiCall(() => svc.spreadsheets.values.update({
-      spreadsheetId: SHEET_ID,
-      range: `OwnerPayouts!I${rowIndex}`,
-      valueInputOption: 'USER_ENTERED',
-      requestBody: { values: [[note]] }
-    }));
+    // Columns:
+    // A payout_id, B user_id, C username, D amount_usd, E channel,
+    // F owner_wallet_or_handle, G request_timestamp_iso, H paid_at_iso,
+    // I status, J notes
+    await retryApiCall(() => svc.spreadsheets.values.batchUpdate({
+      spreadsheetId: SHEET_ID,
+      requestBody: {
+        valueInputOption: 'USER_ENTERED',
+        data: [
+          { range: `OwnerPayouts!H${rowIndex}`, values: [[new Date().toISOString()]] }, // paid_at_iso
+          { range: `OwnerPayouts!I${rowIndex}`, values: [['PAID']] },                   // status
+          { range: `OwnerPayouts!J${rowIndex}`, values: [[note || `Marked by ${markedByUserId}`]] } // notes
+        ]
+      }
+    }));

     console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] Marked owner payout as paid: ${payoutId}`);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Failed to mark owner payout paid:`, error);
     throw error;
   }
 }
diff --git a/src/index.ts b/src/index.ts
index 0000000..0000000 100644
--- a/src/index.ts
+++ b/src/index.ts
@@
 // Buy-in start
 bot.callbackQuery("BUYIN", async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     let settings;
     let owners: any[] = [];
@@
     await ctx.editMessageText(MSG.selectMethod, { reply_markup: kb });
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Buy-in callback failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });
@@
 // Method chosen
 bot.callbackQuery(/METHOD_(.+)/, async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     const method = ctx.match?.[1];
     if (!method) return;
@@
     await ctx.editMessageText(MSG.enterAmount, { reply_markup: kb });
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Method selection failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });
@@
 // Custom amount prompt
 bot.callbackQuery("AMT_CUSTOM", async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     await ctx.editMessageText(`Please enter the amount ($${MIN_BUYIN_AMOUNT}-$${MAX_BUYIN_AMOUNT}):`);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Custom amount prompt failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });
@@
 // Withdrawal button handler
 bot.callbackQuery("WITHDRAW", async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     await startWithdrawFlow(ctx);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Withdraw button failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });

-// Withdrawal channel selection
-bot.callbackQuery("WITHDRAW_START", async (ctx: MyContext) => {
-  try {
-    const kb = new InlineKeyboard()
-      .text('Venmo', 'WD_CH_VENMO').text('Zelle', 'WD_CH_ZELLE').row()
-      .text('PayPal', 'WD_CH_PAYPAL').text('Crypto', 'WD_CH_CRYPTO');
-    await ctx.editMessageText('Choose your withdrawal channel:', { reply_markup: kb });
-  } catch (error) {
-    console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Withdrawal channel selection failed:`, error);
-    await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
-  }
-});
-
-// Circle withdrawal channels
-bot.callbackQuery(/^WD_CH_(VENMO|ZELLE)$/, async (ctx: MyContext) => {
+// Circle withdrawal channels (include CASHAPP too)
+bot.callbackQuery(/^WD_CH_(VENMO|ZELLE|CASHAPP)$/, async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     const method = ctx.match?.[1];
     if (!method) return;

     ctx.session.payoutType = 'CIRCLE';
     ctx.session.method = method;
     ctx.session.step = "WITHDRAW_AMOUNT";

     await ctx.editMessageText(MSG.withdrawAmountPrompt);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Circle withdrawal channel selection failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });

 // PayPal owner payout
 bot.callbackQuery('WD_CH_PAYPAL', async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     ctx.session.payoutType = 'OWNER';
     ctx.session.channel = 'PAYPAL';
     ctx.session.step = "WITHDRAW_AMOUNT";

-    const ownerHandle = FIXED_WALLETS.PAYPAL || 'Owner';
-    await ctx.editMessageText(`PayPal withdrawal will be sent to: ${ownerHandle}\n\n${MSG.withdrawAmountPrompt}`);
+    await ctx.editMessageText(`You chose PayPal withdrawal.\n\n${MSG.withdrawAmountPrompt}`);
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] PayPal withdrawal setup failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });
@@
 bot.callbackQuery('WD_CH_CRYPTO', async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     const coins = ['BTC','ETH','LTC','USDT_ERC20','USDT_TRC20','XRP','SOL'].filter(c => !!FIXED_WALLETS[c]);

     if (coins.length === 0) {
       await ctx.editMessageText('No crypto wallets configured. Please contact support.');
       return;
@@
 // Crypto coin selection
 bot.callbackQuery(/^CRYPTO_(.+)$/, async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     const coin = ctx.match?.[1];
     if (!coin) return;

     ctx.session.cryptoCoin = coin;
     ctx.session.step = "WITHDRAW_AMOUNT";
@@
 // Withdrawal method selection
 bot.callbackQuery(/WITHDRAW_METHOD_(.+)/, async (ctx: MyContext) => {
   try {
+    await ctx.answerCallbackQuery().catch(() => {});
     const method = ctx.match?.[1];
     if (!method) return;

-    ctx.session.method = method;
-    ctx.session.step = "WITHDRAW_AMOUNT";
-    
-    await ctx.editMessageText(MSG.withdrawAmountPrompt);
+    // Decide payout type based on method
+    const settings = await getCachedSettings();
+    const upper = method.toUpperCase();
+    ctx.session.method = upper;
+    if (settings.METHODS_CIRCLE.includes(upper)) {
+      ctx.session.payoutType = 'CIRCLE';
+      ctx.session.step = "WITHDRAW_AMOUNT";
+      await ctx.editMessageText(MSG.withdrawAmountPrompt);
+    } else if (upper === 'PAYPAL') {
+      ctx.session.payoutType = 'OWNER';
+      ctx.session.channel = 'PAYPAL';
+      ctx.session.step = "WITHDRAW_AMOUNT";
+      await ctx.editMessageText(MSG.withdrawAmountPrompt);
+    } else if (upper === 'CRYPTO') {
+      // route to crypto chooser
+      ctx.session.payoutType = 'OWNER';
+      ctx.session.channel = 'CRYPTO';
+      ctx.session.step = "CRYPTO_COIN";
+      const coins = ['BTC','ETH','LTC','USDT_ERC20','USDT_TRC20','XRP','SOL'].filter(c => !!FIXED_WALLETS[c]);
+      const kb = new InlineKeyboard();
+      for (let i = 0; i < coins.length; i += 2) {
+        const row = coins.slice(i, i + 2);
+        if (row.length === 1) kb.text(row[0], `CRYPTO_${row[0]}`); else kb.text(row[0], `CRYPTO_${row[0]}`).text(row[1], `CRYPTO_${row[1]}`);
+        if (i + 2 < coins.length) kb.row();
+      }
+      await ctx.editMessageText('Choose your crypto currency:', { reply_markup: kb });
+    } else {
+      // default OWNER path for any other external method
+      ctx.session.payoutType = 'OWNER';
+      ctx.session.channel = upper;
+      ctx.session.step = "WITHDRAW_AMOUNT";
+      await ctx.editMessageText(MSG.withdrawAmountPrompt);
+    }
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Withdraw method selection failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
   }
 });
@@
 async function startWithdrawFlow(ctx: MyContext) {
   try {
     if (!ctx.from) return;

     ctx.session = {}; // Reset session
-    ctx.session.step = "WITHDRAW_METHOD";
-    
-    // Get available methods from Settings + env fallback
-    const { circleMethods, ownerMethods, allMethods } = await getAvailableMethods();
-    
-    // Create keyboard with available methods
-    const kb = new InlineKeyboard();
-    
-    // Add circle methods first (for matching)
-    const circleButtons = [];
-    for (const method of circleMethods) {
-      circleButtons.push({ text: method, callback: `WITHDRAW_METHOD_${method}` });
-    }
-    
-    // Add owner methods (for owner payouts)
-    const ownerButtons = [];
-    for (const method of ownerMethods) {
-      ownerButtons.push({ text: method, callback: `WITHDRAW_METHOD_${method}` });
-    }
-    
-    // Combine all buttons
-    const allButtons = [...circleButtons, ...ownerButtons];
-    
-    // Check if any methods are available
-    if (allButtons.length === 0) {
-      await ctx.editMessageText("No payment methods are currently available. Please contact the owner to set up payment methods.");
-      return;
-    }
-    
-    // Add methods to keyboard (2 per row)
-    for (let i = 0; i < allButtons.length; i += 2) {
-      const row = allButtons.slice(i, i + 2);
-      if (row.length === 1) {
-        kb.text(row[0].text, row[0].callback);
-      } else {
-        kb.text(row[0].text, row[0].callback).text(row[1].text, row[1].callback);
-      }
-      if (i + 2 < allButtons.length) {
-        kb.row();
-      }
-    }
-    
-    await ctx.editMessageText(MSG.withdrawWelcome, { reply_markup: kb });
+    // Present a clear, stable set of withdraw methods
+    const kb = new InlineKeyboard()
+      .text('Venmo', 'WD_CH_VENMO').text('Zelle', 'WD_CH_ZELLE').row()
+      .text('CashApp', 'WD_CH_CASHAPP').row()
+      .text('PayPal', 'WD_CH_PAYPAL').text('Crypto', 'WD_CH_CRYPTO');
+    await ctx.editMessageText(MSG.withdrawWelcome, { reply_markup: kb });
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Start withdraw flow failed:`, error);
     throw error;
   }
 }
@@
 async function showWithdrawSummary(ctx: MyContext) {
   try {
-    if (!ctx.from || !ctx.session.method || !ctx.session.amount || !ctx.session.tag) {
-      await ctx.reply("Missing withdrawal information. Please start over with /withdraw");
-      return;
-    }
-    
-    const summary = truncateMessage(MSG.withdrawSummary(ctx.session.method, ctx.session.amount, ctx.session.tag));
+    if (!ctx.from) return;
+    const { payoutType, channel, method, amount, tag, cryptoAddress } = ctx.session;
+    if (!method || !amount) {
+      await ctx.reply("Missing withdrawal information. Please start over with /withdraw");
+      return;
+    }
+    // Validate destination depending on type/channel
+    let destination: string | undefined;
+    if (payoutType === 'CIRCLE') {
+      if (!tag) {
+        await ctx.reply("Please provide your handle/phone to receive funds.");
+        return;
+      }
+      destination = tag;
+    } else {
+      if (channel === 'CRYPTO') {
+        if (!cryptoAddress) {
+          await ctx.reply("Please provide your wallet address.");
+          return;
+        }
+        destination = cryptoAddress;
+      } else if (channel === 'PAYPAL') {
+        if (!tag) {
+          await ctx.reply("Please provide your PayPal email.");
+          return;
+        }
+        destination = tag;
+      } else {
+        // generic external channel uses tag as destination
+        if (!tag) {
+          await ctx.reply("Please provide your payout destination.");
+          return;
+        }
+        destination = tag;
+      }
+    }
+
+    const summary = truncateMessage(
+      `Review your withdrawal:\nâ€¢ Method: ${method}\nâ€¢ Amount: $${amount.toFixed(2)}\nâ€¢ Destination: ${destination}\n\nTap "Submit Withdrawal" to send this to loaders.`
+    );
     const kb = new InlineKeyboard().text("Submit Withdrawal", "WITHDRAW_SUBMIT");

     await ctx.reply(summary, { reply_markup: kb });
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Show withdraw summary failed:`, error);
     await ctx.answerCallbackQuery({ text: "Sorry, something went wrong. Please try again.", show_alert: true });
     throw error;
   }
 }
@@
 async function handleWithdrawSubmit(ctx: MyContext) {
   try {
     if (!ctx.from) return;

     const { method, amount, tag, requestTimestampISO } = ctx.session;
     if (!amount || !requestTimestampISO) {
       await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
       return;
     }

     // Generate unique request ID
     const requestId = `wd_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;

     const username = ctx.from.username ? `@${ctx.from.username}` : `${ctx.from.first_name || ""} ${ctx.from.last_name || ""}`.trim();

     try {
       // Get available methods to determine if this is circle or owner
       const { circleMethods, ownerMethods } = await getAvailableMethods();
-      const isCircleMethod = method ? circleMethods.includes(method) : false;
+      const isCircleMethod = method ? circleMethods.includes(method) : false;

       if (isCircleMethod) {
         // Circle withdrawal - use existing flow
         if (!method || !tag) {
           await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
           return;
         }
@@
       } else {
         // Owner withdrawal - goes to Withdrawals with LOGGED status and Owner Payouts
-        if (!method || !tag) {
+        // For OWNER: destination can be PayPal email (tag) or cryptoAddress.
+        const destination = ctx.session.channel === 'CRYPTO' ? ctx.session.cryptoAddress : ctx.session.tag;
+        if (!method || !destination) {
           await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
           return;
         }

         await appendWithdrawalOwner({
           request_id: requestId,
           user_id: ctx.from.id,
           username,
           amount_usd: amount,
           method: method!,
-          payment_tag_or_address: tag!,
+          payment_tag_or_address: destination!,
           request_timestamp_iso: requestTimestampISO,
           notes: 'Owner withdrawal request'
         });
@@
 // Restricted Mark Paid handler
 bot.callbackQuery(/^MARKPAID:(.+?):(.+)$/, async (ctx: MyContext) => {
   try {
     const fromId = ctx.from?.id;
     if (!fromId) return;
+    await ctx.answerCallbackQuery().catch(() => {});

@@
-    const iso = new Date().toISOString();
+    const iso = new Date().toISOString();
     if (requestId && requestId.trim() !== '') {
       // Update UI immediately, then update sheet in background
-      updateWithdrawalStatusById(requestId, 'PAID', `Marked as paid by ${ctx.from?.username ? '@' + ctx.from.username : ctx.from?.first_name || 'Loader'} (${fromId})`)
+      updateWithdrawalStatusById(requestId, 'PAID', String(fromId))
         .then(() => {
           console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] Sheet updated successfully for ${requestId}`);
         })
         .catch((e) => {
           console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] updateWithdrawalStatusById failed:`, e);
           // Sheet update failed, but UI is already updated
         });
     }
@@
   }
 });
@@
 // Handle text for custom amount and withdrawal
 bot.on("message:text", async (ctx: MyContext) => {
   try {
     if (ctx.session.step === "AMOUNT" && ctx.message?.text) {
@@
       await handleAmount(ctx);
     } else if (ctx.session.step === "WITHDRAW_AMOUNT" && ctx.message?.text) {
@@
       ctx.session.amount = validation.value!;

       // Check if this is a circle withdrawal (needs tag) or owner payout (doesn't need tag)
       if (ctx.session.payoutType === 'CIRCLE') {
         ctx.session.step = "WITHDRAW_TAG";
         await ctx.reply(MSG.withdrawTagPrompt);
       } else if (ctx.session.payoutType === 'OWNER') {
-        // For owner payouts, we need the user's wallet address (for crypto) or just proceed
-        if (ctx.session.channel === 'CRYPTO') {
+        // For owner payouts, we need the user's destination:
+        if (ctx.session.channel === 'CRYPTO') {
           ctx.session.step = "CRYPTO_ADDRESS";
           await ctx.reply('Please enter your wallet address:');
+        } else if (ctx.session.channel === 'PAYPAL') {
+          ctx.session.step = "WITHDRAW_TAG";
+          await ctx.reply('Please enter your PayPal email to receive the payout:');
         } else {
-          // PayPal doesn't need additional info
           ctx.session.requestTimestampISO = new Date().toISOString();
           await showWithdrawSummary(ctx);
         }
       }
     } else if (ctx.session.step === "WITHDRAW_TAG" && ctx.message?.text) {
@@
       ctx.session.tag = tagValidation.value!;
       ctx.session.requestTimestampISO = new Date().toISOString();
       await showWithdrawSummary(ctx);
     } else if (ctx.session.step === "CRYPTO_ADDRESS" && ctx.message?.text) {
@@
       ctx.session.cryptoAddress = ctx.message.text;
       ctx.session.requestTimestampISO = new Date().toISOString();
       await showWithdrawSummary(ctx);
@@
     }
   } catch (error) {
     console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Text message handling failed:`, error);
     await ctx.reply("Sorry, something went wrong. Please try again.");
   }
 });
@@
-    const groupId = Number(process.env.LOADER_GROUP_ID);
+    // Support accidental comma-separated env by taking the first valid number
+    const parseGroupIdFromEnv = () => {
+      const raw = process.env.LOADER_GROUP_ID || '';
+      const parts = raw.split(',').map(s => s.trim()).filter(Boolean);
+      for (const p of parts) {
+        const n = Number(p);
+        if (Number.isFinite(n)) return n;
+      }
+      return NaN;
+    };
+    const groupId = parseGroupIdFromEnv();
