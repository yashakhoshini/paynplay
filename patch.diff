Diff to apply to fix issues in paynplay-bot system

This patch includes modifications across multiple files to address slow buttons, correct sheet column indices, improve withdrawal handling, and support proper owner/direct payouts. Apply these changes to your codebase to fix the logic and performance issues described.

1. **src/sheets.ts**

   *Fix updateWithdrawalStatusById to write to the correct columns (approved_by_user_id, approved_at_iso, status)*

```
@@
 export async function updateWithdrawalStatusById(requestId: string, newStatus: string, approvedByUserId?: string): Promise<void> {
@@
-    // Update status and approval info
-    const updates = [
-      { range: `Withdrawals!I${rowIndex}`, values: [[newStatus]] },
-      { range: `Withdrawals!G${rowIndex}`, values: [[approvedByUserId || '']] },
-      { range: `Withdrawals!H${rowIndex}`, values: [[new Date().toISOString()]] }
-    ];
+    // Update status and approval info
+    // Correct column order: H = approved_by_user_id, I = approved_at_iso, J = status
+    const updates = [
+      { range: `Withdrawals!H${rowIndex}`, values: [[approvedByUserId || '']] },
+      { range: `Withdrawals!I${rowIndex}`, values: [[new Date().toISOString()]] },
+      { range: `Withdrawals!J${rowIndex}`, values: [[newStatus]] }
+    ];
```

   *Standardize the `OwnerPayouts` sheet headers to include `paid_at_iso` and `status` (10 columns)*

```
@@ function ensureSheetHeaders(sheetName: string): Promise<void> {
-      case 'OwnerPayouts':
-        headers = [
-          'request_id', 'user_id', 'username', 'amount_usd', 'method', 
-          'payment_tag_or_address', 'request_timestamp_iso', 'status', 'notes'
-        ];
-        break;
+      case 'OwnerPayouts':
+        // Standardize OwnerPayouts headers to include paid_at_iso and status
+        headers = [
+          'request_id',
+          'user_id',
+          'username',
+          'amount_usd',
+          'method',
+          'payment_tag_or_address',
+          'request_timestamp_iso',
+          'paid_at_iso',
+          'status',
+          'notes'
+        ];
+        break;
```

   *Update `appendWithdrawalOwner` to write all 10 columns (including `paid_at_iso` and status)*

```
@@ export async function appendWithdrawalOwner(row: {
-    const ownerPayoutRow = [
-      row.request_id,
-      String(row.user_id),
-      row.username,
-      String(row.amount_usd),
-      row.method,
-      row.payment_tag_or_address,
-      row.request_timestamp_iso,
-      'PENDING', // status
-      row.notes || ''
-    ];
+    const ownerPayoutRow = [
+      row.request_id,
+      String(row.user_id),
+      row.username,
+      String(row.amount_usd),
+      row.method,
+      row.payment_tag_or_address,
+      row.request_timestamp_iso,
+      '',        // paid_at_iso initially empty
+      'PENDING', // status
+      row.notes || ''
+    ];
@@
-    await retryApiCall(() => svc.spreadsheets.values.append({
-      spreadsheetId: SHEET_ID,
-      range: 'OwnerPayouts!A:I',
-      valueInputOption: 'USER_ENTERED',
-      requestBody: { values: [ownerPayoutRow] }
-    }));
+    await retryApiCall(() => svc.spreadsheets.values.append({
+      spreadsheetId: SHEET_ID,
+      range: 'OwnerPayouts!A:J',
+      valueInputOption: 'USER_ENTERED',
+      requestBody: { values: [ownerPayoutRow] }
+    }));
```

   *Correct `markOwnerPayoutPaid` to update the right columns in the OwnerPayouts sheet*

```
@@ export async function markOwnerPayoutPaid(payoutId: string, markedByUserId: number, note: string): Promise<void> {
-    // Update status to PAID
-    await retryApiCall(() => svc.spreadsheets.values.update({
-      spreadsheetId: SHEET_ID,
-      range: `OwnerPayouts!H${rowIndex}`,
-      valueInputOption: 'USER_ENTERED',
-      requestBody: { values: [['PAID']] }
-    }));
-    
-    // Update notes
-    await retryApiCall(() => svc.spreadsheets.values.update({
-      spreadsheetId: SHEET_ID,
-      range: `OwnerPayouts!I${rowIndex}`,
-      valueInputOption: 'USER_ENTERED',
-      requestBody: { values: [[note]] }
-    }));
+    // Columns: H = paid_at_iso, I = status, J = notes
+    await retryApiCall(() => svc.spreadsheets.values.update({
+      spreadsheetId: SHEET_ID,
+      range: `OwnerPayouts!H${rowIndex}`,
+      valueInputOption: 'USER_ENTERED',
+      requestBody: { values: [[new Date().toISOString()]] }
+    }));
+    await retryApiCall(() => svc.spreadsheets.values.update({
+      spreadsheetId: SHEET_ID,
+      range: `OwnerPayouts!I${rowIndex}`,
+      valueInputOption: 'USER_ENTERED',
+      requestBody: { values: [['PAID']] }
+    }));
+    await retryApiCall(() => svc.spreadsheets.values.update({
+      spreadsheetId: SHEET_ID,
+      range: `OwnerPayouts!J${rowIndex}`,
+      valueInputOption: 'USER_ENTERED',
+      requestBody: { values: [[note]] }
+    }));
```

2. **src/index.ts**

   *Add a global middleware to answer callback queries immediately* (prevents long spinners in Telegram)

```
@@
 const bot = initializeBot();

+// Global callback query ack middleware: respond immediately to stop Telegram spinner
+bot.use(async (ctx, next) => {
+  if (ctx.callbackQuery) {
+    try {
+      await ctx.answerCallbackQuery();
+    } catch (e) {
+      // ignore
+    }
+  }
+  await next();
+});
+
+// Helper to parse LOADER_GROUP_ID env var (comma-separated)
+function getLoaderGroupId(): number | null {
+  const raw = String(LOADER_GROUP_ID || process.env.LOADER_GROUP_ID || '').trim();
+  if (!raw) return null;
+  const parts = raw.split(',').map(s => Number(s.trim())).filter(n => Number.isFinite(n));
+  // Prefer negative group chat id; fall back to first numeric entry
+  const chosen = parts.find(n => n < 0) ?? parts[0];
+  return Number.isFinite(chosen) ? chosen : null;
+}
```

   *Use `getLoaderGroupId()` instead of converting `LOADER_GROUP_ID` to a number*. For example:

```
@@
-    const groupId = Number(process.env.LOADER_GROUP_ID);
+    const groupId = getLoaderGroupId();
```

   Apply similar replacements wherever `LOADER_GROUP_ID` is used.

   *Fix PayPal withdrawal flow: request the player's PayPal email instead of routing them to pay the owner*

```
@@ bot.callbackQuery('WD_CH_PAYPAL', async (ctx: MyContext) => {
-    ctx.session.payoutType = 'OWNER';
-    ctx.session.channel = 'PAYPAL';
-    ctx.session.step = "WITHDRAW_AMOUNT";
-    
-    const ownerHandle = FIXED_WALLETS.PAYPAL || 'Owner';
-    await ctx.editMessageText(`PayPal withdrawal will be sent to: ${ownerHandle}\n\n${MSG.withdrawAmountPrompt}`);
+    // For PayPal withdrawals, treat as direct payout: collect player's PayPal email
+    ctx.session.payoutType = 'OWNER';
+    ctx.session.channel = 'PAYPAL';
+    ctx.session.method = 'PAYPAL';
+    ctx.session.step = "WITHDRAW_TAG";
+    await ctx.editMessageText('Enter your PayPal email (where the club should pay you):');
```

   *Replace `showWithdrawSummary` implementation to handle both circle and owner payouts*

```
@@ async function showWithdrawSummary(ctx: MyContext) {
-    if (!ctx.from || !ctx.session.method || !ctx.session.amount || !ctx.session.tag) {
-      await ctx.reply("Missing withdrawal information. Please start over with /withdraw");
-      return;
-    }
-    
-    const summary = truncateMessage(MSG.withdrawSummary(ctx.session.method, ctx.session.amount, ctx.session.tag));
-    const kb = new InlineKeyboard().text("Submit Withdrawal", "WITHDRAW_SUBMIT");
-    
-    await ctx.reply(summary, { reply_markup: kb });
+    if (!ctx.from || !ctx.session.amount) {
+      await ctx.reply("Missing withdrawal information. Please start over with /withdraw");
+      return;
+    }
+    const isCircle = ctx.session.payoutType === 'CIRCLE';
+    let summary = '';
+    if (isCircle) {
+      if (!ctx.session.method || !ctx.session.tag) {
+        await ctx.reply("Missing method or tag. Please start over with /withdraw");
+        return;
+      }
+      summary = MSG.withdrawSummary(ctx.session.method, ctx.session.amount, ctx.session.tag);
+    } else {
+      // Owner payout: destination is PayPal email or crypto address
+      const dest = ctx.session.channel === 'CRYPTO' ? ctx.session.cryptoAddress : ctx.session.tag;
+      if (!dest) {
+        await ctx.reply('Missing payout destination. Please provide your PayPal email or wallet address.');
+        return;
+      }
+      const methodLabel = ctx.session.channel === 'CRYPTO'
+        ? `${ctx.session.cryptoCoin || 'CRYPTO'}`
+        : ctx.session.channel || 'OWNER';
+      summary =
+        `Review your withdrawal:\n` +
+        `• Method: ${methodLabel}\n` +
+        `• Amount: $${ctx.session.amount.toFixed(2)}\n` +
+        `• Destination: ${dest}\n\n` +
+        `Tap "Submit Withdrawal" to send this to loaders.`;
+    }
+    const kb = new InlineKeyboard().text("Submit Withdrawal", "WITHDRAW_SUBMIT");
+    await ctx.reply(truncateMessage(summary), { reply_markup: kb });
```

   *Rewrite `handleWithdrawSubmit` to distinguish circle withdrawals from owner payouts*

```
@@ async function handleWithdrawSubmit(ctx: MyContext) {
-    const { method, amount, tag, requestTimestampISO } = ctx.session;
-    if (!amount || !requestTimestampISO) {
-      await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
-      return;
-    }
-    
-    // Generate unique request ID
-    const requestId = `wd_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
-    
-    const username = ctx.from.username ? `@${ctx.from.username}` : `${ctx.from.first_name || ""} ${ctx.from.last_name || ""}`.trim();
-    
-    try {
-      // Get available methods to determine if this is circle or owner
-      const { circleMethods, ownerMethods } = await getAvailableMethods();
-             const isCircleMethod = method ? circleMethods.includes(method) : false;
-      
-      if (isCircleMethod) {
-        // Circle withdrawal - use existing flow
-        if (!method || !tag) {
-          await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
-          return;
-        }
-        
-        await appendWithdrawalCircle({
-          request_id: requestId,
-          user_id: ctx.from.id,
-          username,
-          amount_usd: amount,
-          method: method!,
-          payment_tag_or_address: tag!,
-          request_timestamp_iso: requestTimestampISO,
-          notes: 'Circle withdrawal request'
-        });
-        
-        await ctx.answerCallbackQuery();
-        await ctx.editMessageText(MSG.withdrawSubmitted);
-        
-        // Send approval card to loaders group
-        const groupId = Number(process.env.LOADER_GROUP_ID);
-        if (Number.isFinite(groupId)) {
-          const card = truncateMessage(MSG.withdrawCard(requestId, username, ctx.from.id, method, amount, tag, requestTimestampISO));
-          const kb = {
-            inline_keyboard: [[{ text: "✅ Confirm Withdrawal", callback_data: `WITHDRAW_CONFIRM_${requestId}` }]]
-          };
-          
-          try {
-            await bot.api.sendMessage(groupId, card, { 
-              parse_mode: "Markdown", 
-              reply_markup: kb 
-            });
-          } catch (error) {
-            console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Error posting withdrawal request to group:`, error);
-            // Fallback: post to private chat
-            const fallbackText = `🧾 *Withdrawal Request* (Group posting failed)\n\n` + card;
-            await ctx.reply(fallbackText, { parse_mode: "Markdown", reply_markup: kb });
-          }
-        } else {
-          console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] No valid LOADER_GROUP_ID found, posting withdrawal request to private chat`);
-          const card = truncateMessage(MSG.withdrawCard(requestId, username, ctx.from.id, method, amount, tag, requestTimestampISO));
-          const kb = {
-            inline_keyboard: [[{ text: "✅ Mark Paid", callback_data: `WITHDRAW_CONFIRM_${requestId}` }]]
-          };
-          await ctx.reply(card, { parse_mode: "Markdown", reply_markup: kb });
-        }
-        
-      } else {
-        // Owner withdrawal - goes to Withdrawals with LOGGED status and Owner Payouts
-        if (!method || !tag) {
-          await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
-          return;
-        }
-        
-        await appendWithdrawalOwner({
-          request_id: requestId,
-          user_id: ctx.from.id,
-          username,
-          amount_usd: amount,
-          method: method!,
-          payment_tag_or_address: tag!,
-          request_timestamp_iso: requestTimestampISO,
-          notes: 'Owner withdrawal request'
-        });
-        
-        await ctx.answerCallbackQuery();
-        await ctx.editMessageText('Owner withdrawal request submitted successfully.');
-        
-        // Send approval card to loaders group
-        const groupId = Number(process.env.LOADER_GROUP_ID);
-        if (Number.isFinite(groupId)) {
-          const card = `🧾 *Owner Withdrawal Request*\n\nUser: ${username} (${ctx.from.id})\nAmount: $${amount}\nMethod: ${method}\nDestination: ${tag}\n\nRequest ID: ${requestId}`;
-          const kb = {
-            inline_keyboard: [[{ text: "✅ Mark Paid", callback_data: `WITHDRAW_CONFIRM_${requestId}` }]]
-          };
-          
-          try {
-            await bot.api.sendMessage(groupId, card, { 
-              parse_mode: "Markdown", 
-              reply_markup: kb 
-            });
-          } catch (error) {
-            console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Error posting owner withdrawal request to group:`, error);
-            // Fallback: post to private chat
-            const fallbackText = `🧾 *Owner Withdrawal Request* (Group posting failed)\n\n` + card;
-            await ctx.reply(fallbackText, { parse_mode: "Markdown", reply_markup: kb });
-          }
-        }
-      }
-      
-    } catch (error) {
-      console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Error creating withdrawal request:`, error);
-      await ctx.answerCallbackQuery({ text: "Error creating withdrawal request. Please try again.", show_alert: true });
-    }
-    
-    ctx.session = {}; // Reset session
+    const { method, amount, tag, requestTimestampISO } = ctx.session;
+    if (!amount || !requestTimestampISO) {
+      await ctx.answerCallbackQuery({ text: "Missing withdrawal information. Please start over with /withdraw", show_alert: true });
+      return;
+    }
+    const requestId = `wd_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
+    const username = ctx.from.username ? `@${ctx.from.username}` : `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim();
+    try {
+      const { circleMethods } = await getAvailableMethods();
+      const isCircleMethod = ctx.session.payoutType === 'CIRCLE' || (!!ctx.session.method && circleMethods.includes(ctx.session.method));
+      if (isCircleMethod) {
+        // Circle withdrawal: record player's tag and queue it
+        if (!ctx.session.method || !ctx.session.tag) {
+          await ctx.answerCallbackQuery({ text: "Missing method or tag. Start over with /withdraw", show_alert: true });
+          return;
+        }
+        await appendWithdrawalCircle({
+          request_id: requestId,
+          user_id: ctx.from.id,
+          username,
+          amount_usd: amount,
+          method: ctx.session.method!,
+          payment_tag_or_address: ctx.session.tag!,
+          request_timestamp_iso: requestTimestampISO,
+          notes: 'Circle withdrawal request'
+        });
+        await ctx.answerCallbackQuery();
+        await ctx.editMessageText(MSG.withdrawSubmitted);
+        const groupId = getLoaderGroupId();
+        if (groupId != null) {
+          const card =
+            `🧾 *Withdrawal (Circle)*\n` +
+            `ID: ${requestId}\nUser: ${username} (${ctx.from.id})\n` +
+            `Method: ${ctx.session.method}\nAmount: $${amount.toFixed(2)}\nTag: ${ctx.session.tag}\n` +
+            `Requested at: ${requestTimestampISO}\nStatus: QUEUED`;
+          try {
+            await bot.api.sendMessage(groupId, truncateMessage(card), { parse_mode: 'Markdown' });
+          } catch (e) {
+            console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Circle withdraw notify failed:`, e);
+          }
+        }
+      } else {
+        // Owner payout: record player's PayPal email or crypto address
+        const dest = ctx.session.channel === 'CRYPTO' ? ctx.session.cryptoAddress : ctx.session.tag;
+        const methodLabel = ctx.session.channel === 'CRYPTO' ? (ctx.session.cryptoCoin || 'CRYPTO') : (ctx.session.channel || 'OWNER');
+        if (!dest || !methodLabel) {
+          await ctx.answerCallbackQuery({ text: "Missing payout destination.", show_alert: true });
+          return;
+        }
+        await appendWithdrawalOwner({
+          request_id: requestId,
+          user_id: ctx.from.id,
+          username,
+          amount_usd: amount,
+          method: methodLabel,
+          payment_tag_or_address: dest,
+          request_timestamp_iso: requestTimestampISO,
+          notes: 'Owner payout request'
+        });
+        await ctx.answerCallbackQuery();
+        await ctx.editMessageText('Withdrawal submitted for direct payout. Loaders will mark it paid once processed.');
+        const groupId = getLoaderGroupId();
+        if (groupId != null) {
+          const card =
+            `🧾 *Owner Payout Request*\n` +
+            `ID: ${requestId}\nUser: ${username} (${ctx.from.id})\n` +
+            `Method: ${methodLabel}\nAmount: $${amount.toFixed(2)}\nDestination: ${dest}\n` +
+            `Requested at: ${requestTimestampISO}\nStatus: PENDING`;
+          const kb = { inline_keyboard: [[{ text: '✅ Mark Paid', callback_data: `WITHDRAW_CONFIRM_${requestId}` }]] };
+          try {
+            await bot.api.sendMessage(groupId, truncateMessage(card), { parse_mode: 'Markdown', reply_markup: kb });
+          } catch (e) {
+            console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Owner payout notify failed:`, e);
+            await ctx.reply(card, { parse_mode: 'Markdown', reply_markup: kb });
+          }
+        }
+      }
+    } catch (error) {
+      console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] Error creating withdrawal request:`, error);
+      await ctx.answerCallbackQuery({ text: 'Error creating withdrawal request. Please try again.', show_alert: true });
+    }
+    ctx.session = {};
```

   *Update `handleWithdrawConfirm` so that confirming an owner payout also updates the OwnerPayouts sheet*

```
@@ async function handleWithdrawConfirm(ctx: MyContext) {
-      await updateWithdrawalStatusById(requestId, 'PAID', `Marked as paid by ${ctx.from?.username ? '@' + ctx.from.username : ctx.from?.first_name || 'Admin'} (${fromId})`);
-      
-      // Update the message to show confirmation
-      const verifier = ctx.from?.username ? `@${ctx.from.username}` : `${ctx.from?.first_name || 'Admin'} (${fromId})`;
-      await ctx.editMessageText(`✅ Withdrawal marked as paid by ${verifier} at ${new Date().toISOString()}`, {
-        reply_markup: { inline_keyboard: [] }
-      });
-      
-      await ctx.answerCallbackQuery({ text: 'Withdrawal marked as paid ✅' });
+      await updateWithdrawalStatusById(requestId, 'PAID', `${fromId}`);
+      const verifier = ctx.from?.username ? `@${ctx.from.username}` : `${ctx.from?.first_name || 'Admin'} (${fromId})`;
+      await ctx.editMessageText(`✅ Withdrawal marked as paid by ${verifier} at ${new Date().toISOString()}`, {
+        reply_markup: { inline_keyboard: [] }
+      });
+      // Also mark OwnerPayouts row as paid if this was a direct payout
+      try {
+        await markOwnerPayoutPaid(requestId, fromId, `Marked paid by ${verifier}`);
+      } catch (e) {
+        console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] markOwnerPayoutPaid failed:`, e);
+      }
+      await ctx.answerCallbackQuery({ text: 'Withdrawal marked as paid ✅' });
```

   *Modify Mark Paid callback data to include a sentinel when there is no circle withdrawal ID and accept empty matches*

```
@@ async function handleAmount(ctx: MyContext) {
-    const kb = {
-      inline_keyboard: [
-        [{ text: '✅ Mark Paid', callback_data: `MARKPAID:${buyinId}:${match.type === 'CASHOUT' ? match.request_id || '' : ''}` }]
-      ]
-    };
+    const callbackRequestId = match.type === 'CASHOUT' ? (match.request_id || 'NONE') : 'NONE';
+    const kb = {
+      inline_keyboard: [
+        [{ text: '✅ Mark Paid', callback_data: `MARKPAID:${buyinId}:${callbackRequestId}` }]
+      ]
+    };
@@
-bot.callbackQuery(/^MARKPAID:(.+?):(.+)$/, async (ctx: MyContext) => {
+bot.callbackQuery(/^MARKPAID:([^:]+):([^:]*)$/, async (ctx: MyContext) => {
@@
-    const buyinId = ctx.match?.[1];
-    const requestId = ctx.match?.[2]; // Empty string means owner route (no cashout row to mark)
+    const buyinId = ctx.match?.[1];
+    const requestId = ctx.match?.[2]; // 'NONE' or empty string for owner route
@@
-    if (requestId && requestId.trim() !== '') {
-      // Update UI immediately, then update sheet in background
-      updateWithdrawalStatusById(requestId, 'PAID', `Marked as paid by ${ctx.from?.username ? '@' + ctx.from.username : ctx.from?.first_name || 'Loader'} (${fromId})`)
-        .then(() => {
-          console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] Sheet updated successfully for ${requestId}`);
-        })
-        .catch((e) => {
-          console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] updateWithdrawalStatusById failed:`, e);
-          // Sheet update failed, but UI is already updated
-        });
-    }
+    if (requestId && requestId !== 'NONE') {
+      updateWithdrawalStatusById(requestId, 'PAID', `${fromId}`)
+        .then(() => {
+          console.log(`[${new Date().toISOString()}] [${CLIENT_NAME}] Sheet updated successfully for ${requestId}`);
+        })
+        .catch((e) => {
+          console.error(`[${new Date().toISOString()}] [${CLIENT_NAME}] updateWithdrawalStatusById failed:`, e);
+        });
+    }
```

   *Build owner method list correctly in `getAvailableMethods()`*

```
@@ async function getAvailableMethods(): Promise<{
-    // Get owner methods from settings (owner payment addresses)
-    const ownerMethods = [];
-         if (settings.APPLE_PAY_HANDLE) ownerMethods.push('APPLEPAY');
-     if (settings.CASHAPP_HANDLE) ownerMethods.push('CASHAPP');
-     if (settings.PAYPAL_EMAIL) ownerMethods.push('PAYPAL');
-     if (settings.CRYPTO_WALLET_BTC) ownerMethods.push('BTC');
-     if (settings.CRYPTO_WALLET_ETH) ownerMethods.push('ETH');
-     if (settings.CRYPTO_WALLET) {
-       // Add other crypto networks
-       const networks = settings.CRYPTO_NETWORKS;
-      for (const network of networks) {
-        if (network !== 'BTC' && network !== 'ETH') {
-          ownerMethods.push(network);
-        }
-      }
-    }
+    // Build owner methods list from configured handles
+    const ownerMethods: string[] = [];
+    if (settings.APPLE_PAY_HANDLE) ownerMethods.push('APPLE PAY');
+    if (settings.CASHAPP_HANDLE) ownerMethods.push('CASHAPP');
+    if (settings.PAYPAL_EMAIL) ownerMethods.push('PAYPAL');
+    if (settings.CRYPTO_WALLET_BTC) ownerMethods.push('BTC');
+    if (settings.CRYPTO_WALLET_ETH) ownerMethods.push('ETH');
+    if (settings.CRYPTO_WALLET) {
+      const networks = settings.CRYPTO_NETWORKS || [];
+      for (const network of networks) {
+        const upper = network.trim().toUpperCase();
+        if (upper !== 'BTC' && upper !== 'ETH' && !ownerMethods.includes(upper)) {
+          ownerMethods.push(upper);
+        }
+      }
+    }
```

   *Change external deposit logging to label the method as `CARD` instead of `EXTERNAL`* (for Stripe/Apple Pay)

```
@@ bot.on("message:text", async (ctx: MyContext) => {
-         await appendExternalDeposit({
-           entry_id: entryId,
-           user_id: ctx.from?.id || 0,
-           username,
-           amount_usd: ctx.session.externalAmount || 0,
-           method: 'EXTERNAL',
-           reference: ctx.session.externalReference,
-           created_at_iso: new Date().toISOString(),
-           recorded_by_user_id: ctx.from?.id || 0
-         });
+         await appendExternalDeposit({
+           entry_id: entryId,
+           user_id: ctx.from?.id || 0,
+           username,
+           amount_usd: ctx.session.externalAmount || 0,
+           method: 'CARD',
+           reference: ctx.session.externalReference,
+           created_at_iso: new Date().toISOString(),
+           recorded_by_user_id: ctx.from?.id || 0
+         });
```

3. **Environment and deployment**

   - **Rotate your secrets** (BOT_TOKEN and Google private key) immediately after deploying these changes. Never share them publicly.
   - **Set `LOADER_GROUP_ID` to a single negative chat id**. Example:

     ```env
     LOADER_GROUP_ID=-6043251197
     OWNER_IDS=6043251197
     LOADER_IDS=5288492604
     ALLOWED_USER_IDS=6043251197,5288492604
     ```

   - Ensure your `BOT_TOKEN` follows the `123456789:ABCdef...` format.
   - Update `METHODS_CIRCLE`, `METHODS_EXTERNAL_LINK` to match your allowed methods.
   - Set `MAX_BUYIN_AMOUNT` to `2000` to enforce a $2,000 maximum buy-in.

4. **Testing**

   After deploying the patched bot, perform these tests:

   1. **Buy-In (Circle):**
      - Run `/start` → Buy-In → choose *Venmo* → $25. The bot should route the payment to either a pending circle withdrawal or the owner. The “Mark Paid” button should appear, and clicking it should instantly update the group card.

   2. **Circle Withdrawal:**
      - Run `/withdraw` → choose *Venmo* → $50 → enter your Venmo handle → submit. The request should be logged as `QUEUED` (column J) in the `Withdrawals` sheet. There should be no prompt to pay the owner.

   3. **Owner Payout (PayPal):**
      - Run `/withdraw` → choose *PayPal* → enter $75 → enter your PayPal email → submit. The bot should acknowledge the payout request and send a card to the loaders with a “✅ Mark Paid” button. When a loader clicks that button, both the `Withdrawals` sheet (column J) and the `OwnerPayouts` sheet (columns H–J) should update to reflect the payment.

   4. **Speed Test:**
      - Ensure that all buttons (Mark Paid, Confirm Withdrawal, etc.) respond instantly (spinner stops immediately) thanks to the global callback ack middleware.

   If any step fails, check your Railway logs and make sure the environment variables are set correctly.
